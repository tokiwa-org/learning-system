# カリキュラム生成ロジック仕様

## 概要

本ドキュメントは人事考課システムにおけるカリキュラム自動生成の詳細仕様を定義します。
Neo4jオントロジーのNoiseType、LearningPhase、Scenario、Curriculum、WorkflowDefinitionから派生しています。

## システム構成

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        カリキュラム生成パイプライン                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                │
│  │   シナリオ    │────▶│  プロンプト  │────▶│ Cloudflare AI │               │
│  │   (Scenario) │     │   ビルダー   │     │ (LLM)        │                │
│  └──────────────┘     └──────────────┘     └──────┬───────┘                │
│                                                    │                        │
│                                                    ▼                        │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                │
│  │  ノイズ注入   │◀────│   構造化     │◀────│  LLM出力     │                │
│  │  (NoiseType) │     │   パーサー   │     │  (JSON)      │                │
│  └──────┬───────┘     └──────────────┘     └──────────────┘                │
│         │                                                                   │
│         ▼                                                                   │
│  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐                │
│  │  カリキュラム │────▶│   有識者     │────▶│   社員配信   │                │
│  │   (Draft)    │     │   レビュー   │     │  (Publish)   │                │
│  └──────────────┘     └──────────────┘     └──────────────┘                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 学習フェーズ

オントロジーのLearningPhaseから派生:

| フェーズ | コード | 目的 | ノイズ戦略 |
|---------|-------|------|-----------|
| フィルタリング学習 | `PHASE1_FILTERING` | 正解の型を脳に刻む | 1箇所だけ古い書き方を混ぜる |
| デバッグ・リファクタリング学習 | `PHASE2_REFACTORING` | 保守性の低いコードを改善する力 | 動くが保守性が低いコード |
| 要件定義・アーキテクチャ学習 | `PHASE3_ARCHITECTURE` | 曖昧な要望から仕様を抽出 | 矛盾・不足のある要件 |

## ノイズタイプ

オントロジーのNoiseTypeから派生:

| コード | 名称 | 説明 | 適用フェーズ |
|--------|------|------|-------------|
| `SEARCH_POLLUTION` | 検索環境の汚染 | 似た名前の別技術、廃止されたAPIの検索結果 | PHASE1, PHASE2 |
| `INCOMPLETE_INFO` | 情報の不完全性 | 意図的な考慮漏れがある仕様書、古いドキュメント | PHASE2, PHASE3 |
| `EXCESSIVE_OPTIONS` | 選択肢の過剰 | 複数の解決策の提示、正解のない技術選定 | PHASE2, PHASE3 |
| `CONTEXT_FLUCTUATION` | コンテキストの揺らぎ | 途中で変わる優先順位、曖昧な要望 | PHASE3 |
| `TECHNICAL_DEBT` | 技術的負債 | 密結合なレガシーコード、一貫性のない命名規則 | PHASE2 |

### ノイズ適用ルール

```typescript
interface NoiseConfig {
  type: NoiseType;
  intensity: 'LOW' | 'MEDIUM' | 'HIGH';
  placement: 'BEGINNING' | 'MIDDLE' | 'END' | 'RANDOM';
  ratio: number; // 0.0 - 1.0 (ノイズの割合)
}

// フェーズごとのデフォルトノイズ設定
const PHASE_NOISE_DEFAULTS: Record<LearningPhase, NoiseConfig[]> = {
  PHASE1_FILTERING: [
    { type: 'SEARCH_POLLUTION', intensity: 'LOW', placement: 'RANDOM', ratio: 0.1 }
  ],
  PHASE2_REFACTORING: [
    { type: 'TECHNICAL_DEBT', intensity: 'MEDIUM', placement: 'BEGINNING', ratio: 0.3 },
    { type: 'INCOMPLETE_INFO', intensity: 'LOW', placement: 'MIDDLE', ratio: 0.2 }
  ],
  PHASE3_ARCHITECTURE: [
    { type: 'CONTEXT_FLUCTUATION', intensity: 'HIGH', placement: 'RANDOM', ratio: 0.4 },
    { type: 'EXCESSIVE_OPTIONS', intensity: 'MEDIUM', placement: 'MIDDLE', ratio: 0.3 }
  ]
};
```

## シナリオ構造

### シナリオエンティティ

```typescript
interface Scenario {
  id: string;
  title: string;
  description: string;
  targetGrade: Grade;           // 対象等級
  learningPhase: LearningPhase; // 学習フェーズ
  category: SkillCategory;      // スキルカテゴリ
  difficulty: 1 | 2 | 3 | 4 | 5;
  estimatedMinutes: number;
  questions: ScenarioQuestion[];
  status: 'DRAFT' | 'ACTIVE' | 'ARCHIVED';
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

interface ScenarioQuestion {
  id: string;
  order: number;
  questionText: string;
  context?: string;             // 追加コンテキスト
  expectedApproach: string;     // 期待されるアプローチ（採点用）
  hints?: string[];             // ヒント（オプション）
  relatedRoadmapItems: string[]; // 関連ロードマップ項目
}
```

### シナリオ例（PHASE2_REFACTORING）

```json
{
  "id": "scenario_001",
  "title": "レガシー認証システムのリファクタリング",
  "description": "10年前に構築された認証システムを、モダンなアーキテクチャに移行する",
  "targetGrade": "G3",
  "learningPhase": "PHASE2_REFACTORING",
  "category": "BACKEND",
  "difficulty": 3,
  "estimatedMinutes": 60,
  "questions": [
    {
      "id": "q_001",
      "order": 1,
      "questionText": "以下のコードの問題点を指摘し、改善案を提示してください",
      "context": "```javascript\nfunction authenticate(user, pass) {\n  var query = \"SELECT * FROM users WHERE username='\" + user + \"' AND password='\" + pass + \"'\";\n  // ... 以下略\n}\n```",
      "expectedApproach": "SQLインジェクション脆弱性の指摘、PreparedStatementへの移行、パスワードハッシュ化の提案",
      "relatedRoadmapItems": ["rm_security_001", "rm_backend_002"]
    }
  ]
}
```

## カリキュラム生成プロセス

### 1. プロンプト構築

```typescript
// domain/services/curriculum-generator.ts

interface CurriculumGenerationInput {
  scenario: Scenario;
  noiseConfig: NoiseConfig[];
  targetAudience: {
    grade: Grade;
    department: string;
    experienceYears: number;
  };
}

function buildPrompt(input: CurriculumGenerationInput): string {
  const { scenario, noiseConfig, targetAudience } = input;

  return `
あなたは企業研修カリキュラムの設計者です。
以下のシナリオに基づいて、実践的な学習カリキュラムを生成してください。

## シナリオ情報
タイトル: ${scenario.title}
説明: ${scenario.description}
学習フェーズ: ${scenario.learningPhase}
難易度: ${scenario.difficulty}/5
想定所要時間: ${scenario.estimatedMinutes}分

## 対象者
等級: ${targetAudience.grade}
部署: ${targetAudience.department}
経験年数: ${targetAudience.experienceYears}年

## 設問
${scenario.questions.map((q, i) => `
### 設問${i + 1}
${q.questionText}

コンテキスト:
${q.context || 'なし'}
`).join('\n')}

## 生成指示
以下の形式でカリキュラムを生成してください。各項目には「ノイズ」を含めてください。
ノイズとは、実際の業務で遭遇する不正確な情報や誤解を招く情報のことです。
学習者はノイズを見分ける能力を養う必要があります。

### ノイズ設定
${noiseConfig.map(n => `- ${n.type}: 強度=${n.intensity}, 割合=${n.ratio * 100}%`).join('\n')}

## 出力形式 (JSON)
{
  "title": "カリキュラムタイトル",
  "overview": "概要説明",
  "learningObjectives": ["目標1", "目標2"],
  "items": [
    {
      "order": 1,
      "title": "項目タイトル",
      "type": "READING" | "EXERCISE" | "QUIZ" | "DISCUSSION",
      "content": "学習コンテンツ（Markdown形式）",
      "noiseElements": [
        {
          "type": "ノイズタイプ",
          "description": "どのようなノイズか",
          "location": "コンテンツ内の位置",
          "correctInfo": "正しい情報"
        }
      ],
      "estimatedMinutes": 10,
      "relatedRoadmapItems": ["rm_xxx"]
    }
  ],
  "assessmentCriteria": ["評価基準1", "評価基準2"]
}
`;
}
```

### 2. LLM呼び出し

```typescript
// infrastructure/ai/cloudflare-ai-client.ts

interface CloudflareAIConfig {
  model: string;
  maxTokens: number;
  temperature: number;
}

const DEFAULT_CONFIG: CloudflareAIConfig = {
  model: '@cf/meta/llama-3.1-8b-instruct',
  maxTokens: 4096,
  temperature: 0.7
};

export async function generateCurriculum(
  env: Env,
  prompt: string,
  config: CloudflareAIConfig = DEFAULT_CONFIG
): Promise<CurriculumGenerationResult> {
  const startTime = Date.now();

  try {
    const response = await env.AI.run(config.model, {
      prompt,
      max_tokens: config.maxTokens,
      temperature: config.temperature
    });

    const duration = Date.now() - startTime;

    // レスポンスのパース
    const parsed = parseLLMResponse(response.response);

    return {
      success: true,
      data: parsed,
      metadata: {
        model: config.model,
        duration,
        tokenCount: response.usage?.total_tokens
      }
    };
  } catch (error) {
    logger.error('CURRICULUM', 'LLM generation failed', error as Error);

    throw new ExternalServiceError(
      'EXTERNAL_AI_GENERATION_FAILED',
      'Cloudflare AI',
      error as Error
    );
  }
}

function parseLLMResponse(response: string): CurriculumDraft {
  // JSONブロックを抽出
  const jsonMatch = response.match(/```json\n?([\s\S]*?)\n?```/) ||
                    response.match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    throw new Error('LLM response does not contain valid JSON');
  }

  const jsonStr = jsonMatch[1] || jsonMatch[0];
  const parsed = JSON.parse(jsonStr);

  // スキーマバリデーション
  return validateCurriculumSchema(parsed);
}
```

### 3. ノイズ注入

```typescript
// domain/services/noise-injector.ts

interface NoiseElement {
  type: NoiseType;
  description: string;
  location: string;
  correctInfo: string;
}

export class NoiseInjector {
  inject(
    content: string,
    noiseConfig: NoiseConfig[],
    context: { learningPhase: LearningPhase; difficulty: number }
  ): { content: string; injectedNoise: NoiseElement[] } {
    const injectedNoise: NoiseElement[] = [];

    let processedContent = content;

    for (const config of noiseConfig) {
      const noiseResult = this.applyNoise(processedContent, config, context);
      processedContent = noiseResult.content;
      injectedNoise.push(...noiseResult.noise);
    }

    return { content: processedContent, injectedNoise };
  }

  private applyNoise(
    content: string,
    config: NoiseConfig,
    context: { learningPhase: LearningPhase; difficulty: number }
  ): { content: string; noise: NoiseElement[] } {
    switch (config.type) {
      case 'SEARCH_POLLUTION':
        return this.injectSearchPollution(content, config);
      case 'INCOMPLETE_INFO':
        return this.injectIncompleteInfo(content, config);
      case 'EXCESSIVE_OPTIONS':
        return this.injectExcessiveOptions(content, config);
      case 'CONTEXT_FLUCTUATION':
        return this.injectContextFluctuation(content, config);
      case 'TECHNICAL_DEBT':
        return this.injectTechnicalDebt(content, config);
      default:
        return { content, noise: [] };
    }
  }

  // 検索環境の汚染: 似た名前の技術や廃止されたAPIを混入
  private injectSearchPollution(
    content: string,
    config: NoiseConfig
  ): { content: string; noise: NoiseElement[] } {
    const pollutionPatterns = [
      { search: /React\.Component/g, replace: 'React.createClass', correct: 'React.Component' },
      { search: /async\/await/g, replace: 'callback pattern', correct: 'async/await' },
      { search: /fetch\(/g, replace: 'XMLHttpRequest', correct: 'fetch()' },
      { search: /const /g, replace: 'var ', correct: 'const' }
    ];

    // 設定された割合に基づいてパターンを適用
    const applicableCount = Math.ceil(pollutionPatterns.length * config.ratio);
    const selectedPatterns = this.selectByPlacement(pollutionPatterns, applicableCount, config.placement);

    let processedContent = content;
    const noise: NoiseElement[] = [];

    for (const pattern of selectedPatterns) {
      if (pattern.search.test(processedContent)) {
        processedContent = processedContent.replace(pattern.search, pattern.replace);
        noise.push({
          type: 'SEARCH_POLLUTION',
          description: `古い技術パターン "${pattern.replace}" が混入`,
          location: 'コード例内',
          correctInfo: `正しくは "${pattern.correct}" を使用`
        });
      }
    }

    return { content: processedContent, noise };
  }

  // 情報の不完全性: 重要な情報を意図的に省略
  private injectIncompleteInfo(
    content: string,
    config: NoiseConfig
  ): { content: string; noise: NoiseElement[] } {
    // エラーハンドリングの省略、エッジケースの無視など
    const omissions = [
      { pattern: /try\s*\{[\s\S]*?\}\s*catch[\s\S]*?\{[\s\S]*?\}/g, description: 'エラーハンドリングが省略されています' },
      { pattern: /if\s*\([^)]*null[^)]*\)/g, description: 'nullチェックが省略されています' }
    ];

    // 実装省略...
    return { content, noise: [] };
  }

  // その他のノイズ注入メソッド...
  private injectExcessiveOptions(content: string, config: NoiseConfig) { /* ... */ return { content, noise: [] }; }
  private injectContextFluctuation(content: string, config: NoiseConfig) { /* ... */ return { content, noise: [] }; }
  private injectTechnicalDebt(content: string, config: NoiseConfig) { /* ... */ return { content, noise: [] }; }

  private selectByPlacement<T>(items: T[], count: number, placement: NoiseConfig['placement']): T[] {
    switch (placement) {
      case 'BEGINNING':
        return items.slice(0, count);
      case 'END':
        return items.slice(-count);
      case 'MIDDLE':
        const start = Math.floor((items.length - count) / 2);
        return items.slice(start, start + count);
      case 'RANDOM':
      default:
        return this.shuffleArray(items).slice(0, count);
    }
  }

  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
}
```

### 4. カリキュラム構造

```typescript
// domain/entities/curriculum.ts

interface Curriculum {
  id: string;
  scenarioId: string;
  title: string;
  overview: string;
  learningPhase: LearningPhase;
  targetGrade: Grade;
  estimatedMinutes: number;
  learningObjectives: string[];
  assessmentCriteria: string[];
  items: CurriculumItem[];
  noiseMetadata: {
    totalNoiseElements: number;
    noiseByType: Record<NoiseType, number>;
    difficultyModifier: number;
  };
  status: 'DRAFT' | 'UNDER_REVIEW' | 'APPROVED' | 'PUBLISHED' | 'ARCHIVED';
  generatedBy: 'LLM' | 'MANUAL';
  generationMetadata?: {
    model: string;
    duration: number;
    tokenCount: number;
    generatedAt: string;
  };
  reviewedBy?: string;
  reviewedAt?: string;
  publishedAt?: string;
  createdAt: string;
  updatedAt: string;
}

interface CurriculumItem {
  id: string;
  order: number;
  title: string;
  type: 'READING' | 'EXERCISE' | 'QUIZ' | 'DISCUSSION';
  content: string;                    // Markdown形式
  noiseElements: NoiseElement[];
  estimatedMinutes: number;
  relatedRoadmapItems: string[];
  hints?: string[];
  references?: {
    title: string;
    url: string;
    isNoise: boolean;                 // ノイズ参照かどうか
  }[];
}
```

## ワークフロー

### カリキュラム作成ワークフロー

オントロジーのWorkflowDefinitionから派生:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        カリキュラム作成ワークフロー                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐              │
│  │ シナリオ  │───▶│ カリキュラム│───▶│ 有識者   │───▶│  配信    │              │
│  │ 作成     │    │ 生成     │    │ 査閲     │    │         │              │
│  └──────────┘    └──────────┘    └────┬─────┘    └──────────┘              │
│                                       │                                     │
│      HR担当           システム        │  承認/差戻し     システム            │
│                        (LLM)          ▼                                     │
│                                  ┌──────────┐                               │
│                                  │  修正    │◀─────────────┐               │
│                                  └──────────┘              │               │
│                                       │                    │差戻し          │
│                                       └────────────────────┘               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 状態遷移

| 現在状態 | アクション | 次状態 | アクター |
|---------|-----------|-------|---------|
| - | createScenario | DRAFT | HR |
| DRAFT | generateCurriculum | UNDER_REVIEW | SYSTEM |
| UNDER_REVIEW | approve | APPROVED | REVIEWER |
| UNDER_REVIEW | reject | DRAFT | REVIEWER |
| APPROVED | publish | PUBLISHED | SYSTEM |
| PUBLISHED | archive | ARCHIVED | HR |

## 有識者レビュー

### レビュー観点

```typescript
interface ReviewChecklist {
  technicalAccuracy: {
    // 技術的正確性
    codeExamplesValid: boolean;
    bestPracticesFollowed: boolean;
    securityConsiderations: boolean;
  };
  noiseQuality: {
    // ノイズの質
    noiseIsIdentifiable: boolean;      // 学習者が識別可能か
    noiseDifficultyAppropriate: boolean; // 難易度は適切か
    correctInfoProvided: boolean;       // 正解が提供されているか
  };
  pedagogicalQuality: {
    // 教育的品質
    objectivesClear: boolean;
    progressionLogical: boolean;
    assessmentAligned: boolean;
  };
  contentQuality: {
    // コンテンツ品質
    writingClarity: boolean;
    formatConsistent: boolean;
    lengthAppropriate: boolean;
  };
}

interface ReviewResult {
  checklistResults: ReviewChecklist;
  overallScore: 1 | 2 | 3 | 4 | 5;
  comments: string;
  suggestedChanges?: string[];
  decision: 'APPROVE' | 'REQUEST_CHANGES' | 'REJECT';
}
```

### レビューAPI

```typescript
// POST /api/v1/curriculums/{curriculumId}/review
interface ReviewRequest {
  decision: 'APPROVE' | 'REQUEST_CHANGES' | 'REJECT';
  checklist: ReviewChecklist;
  overallScore: number;
  comments: string;
  suggestedChanges?: string[];
}

// Response
interface ReviewResponse {
  success: true;
  data: {
    curriculumId: string;
    newStatus: CurriculumStatus;
    review: ReviewResult;
    nextSteps: string[];
  };
}
```

## 社員配信

### 配信ロジック

```typescript
// domain/services/curriculum-distributor.ts

interface DistributionCriteria {
  targetGrades: Grade[];
  targetDepartments?: string[];
  targetEmployees?: string[];      // 特定社員への配信
  excludeEmployees?: string[];     // 除外社員
  dueDate: string;                 // 完了期限
  priority: 'LOW' | 'MEDIUM' | 'HIGH';
}

export class CurriculumDistributor {
  async distribute(
    curriculumId: string,
    criteria: DistributionCriteria
  ): Promise<DistributionResult> {
    // 対象社員を特定
    const targetEmployees = await this.findTargetEmployees(criteria);

    // カリキュラムアサインメントを作成
    const assignments = await this.createAssignments(curriculumId, targetEmployees, criteria);

    // 通知をキューイング
    await this.queueNotifications(assignments);

    return {
      curriculumId,
      assignmentCount: assignments.length,
      assignments: assignments.map(a => ({
        employeeId: a.employeeId,
        assignmentId: a.id,
        dueDate: a.dueDate
      }))
    };
  }

  private async findTargetEmployees(criteria: DistributionCriteria): Promise<Employee[]> {
    // 等級、部署でフィルタリング
    // 除外リストを適用
    // アクティブな社員のみ
    return [];
  }

  private async createAssignments(
    curriculumId: string,
    employees: Employee[],
    criteria: DistributionCriteria
  ): Promise<CurriculumAssignment[]> {
    return employees.map(emp => ({
      id: generateId('assign'),
      curriculumId,
      employeeId: emp.id,
      status: 'PENDING',
      dueDate: criteria.dueDate,
      assignedAt: new Date().toISOString()
    }));
  }

  private async queueNotifications(assignments: CurriculumAssignment[]): Promise<void> {
    for (const assignment of assignments) {
      await this.notificationQueue.send({
        type: 'CURRICULUM_ASSIGNED',
        recipientId: assignment.employeeId,
        data: {
          curriculumId: assignment.curriculumId,
          assignmentId: assignment.id,
          dueDate: assignment.dueDate
        }
      });
    }
  }
}
```

## 学習進捗管理

### 進捗追跡

```typescript
interface LearningProgress {
  id: string;
  assignmentId: string;
  employeeId: string;
  curriculumId: string;
  status: 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED';
  startedAt?: string;
  completedAt?: string;
  itemProgress: ItemProgress[];
  totalScore?: number;
  timeSpentMinutes: number;
}

interface ItemProgress {
  itemId: string;
  status: 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED';
  startedAt?: string;
  completedAt?: string;
  score?: number;
  attempts: number;
  noiseIdentified: string[];       // 識別できたノイズ
  noiseMissed: string[];           // 見逃したノイズ
}
```

### 学習完了判定

```typescript
function evaluateLearningCompletion(progress: LearningProgress, curriculum: Curriculum): LearningResult {
  const totalItems = curriculum.items.length;
  const completedItems = progress.itemProgress.filter(p => p.status === 'COMPLETED').length;

  const totalNoise = curriculum.noiseMetadata.totalNoiseElements;
  const identifiedNoise = progress.itemProgress.reduce(
    (sum, p) => sum + p.noiseIdentified.length, 0
  );
  const missedNoise = progress.itemProgress.reduce(
    (sum, p) => sum + p.noiseMissed.length, 0
  );

  const noiseIdentificationRate = totalNoise > 0 ? identifiedNoise / totalNoise : 1;

  return {
    isComplete: completedItems === totalItems,
    itemCompletionRate: completedItems / totalItems,
    noiseIdentificationRate,
    overallScore: calculateOverallScore(progress, curriculum),
    recommendations: generateRecommendations(noiseIdentificationRate, curriculum.learningPhase)
  };
}
```

## エラーハンドリング

### 生成エラー

| エラー | 原因 | 対処 |
|-------|------|------|
| `CURRICULUM_GENERATION_TIMEOUT` | LLM応答タイムアウト | 3回リトライ後に手動対応 |
| `CURRICULUM_PARSE_ERROR` | LLM出力が不正JSON | プロンプト調整して再生成 |
| `CURRICULUM_VALIDATION_ERROR` | スキーマ不整合 | エラー内容をログし手動確認 |
| `NOISE_INJECTION_ERROR` | ノイズ注入失敗 | ノイズなしで生成続行 |

### リトライ戦略

```typescript
const GENERATION_RETRY_CONFIG = {
  maxRetries: 3,
  baseDelayMs: 2000,
  maxDelayMs: 30000,
  retryableErrors: [
    'CURRICULUM_GENERATION_TIMEOUT',
    'EXTERNAL_AI_GENERATION_FAILED'
  ]
};
```

## 監視・メトリクス

### 生成品質メトリクス

| メトリクス | 説明 | 目標値 |
|-----------|------|-------|
| 生成成功率 | LLM生成の成功率 | > 95% |
| レビュー承認率 | 初回レビュー通過率 | > 80% |
| ノイズ識別率 | 学習者のノイズ識別率 | 70-90% |
| 完了率 | カリキュラム完了率 | > 85% |
| 平均所要時間 | 実際の所要時間 / 想定時間 | 0.8-1.2 |

---

_最終更新: 2026年1月24日_
_派生元: Neo4j Ontology (NoiseType, LearningPhase, Scenario, Curriculum, WorkflowDefinition)_

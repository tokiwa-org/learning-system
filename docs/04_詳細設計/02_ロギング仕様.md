# ロギング仕様

## 概要

本ドキュメントは人事考課システムにおけるロギングの詳細仕様を定義します。
Neo4jオントロジーのEventHandler、DomainEvent、BusinessEventから派生しています。

## ログ分類体系

### 1. ログレベル

| レベル | 用途 | 本番出力 |
|-------|------|---------|
| `DEBUG` | 開発時デバッグ情報 | ❌ |
| `INFO` | 通常の処理フロー | ✅ |
| `WARN` | 警告（処理は継続） | ✅ |
| `ERROR` | エラー（処理失敗） | ✅ |
| `FATAL` | 致命的エラー | ✅ |

### 2. ログカテゴリ

オントロジーのEventHandlerから派生:

| カテゴリ | コード | 説明 | 対応ハンドラー |
|---------|-------|------|--------------|
| 監査ログ | `AUDIT` | ユーザー操作の監査記録 | AUDIT_HANDLER |
| 通知ログ | `NOTIFICATION` | 通知送信の記録 | NOTIFICATION_HANDLER |
| ワークフローログ | `WORKFLOW` | 状態遷移の記録 | WORKFLOW_HANDLER |
| スナップショットログ | `SNAPSHOT` | データスナップショットの記録 | SNAPSHOT_HANDLER |
| アクセスログ | `ACCESS` | APIアクセスの記録 | - |
| エラーログ | `ERROR` | エラー詳細の記録 | - |
| パフォーマンスログ | `PERFORMANCE` | 性能測定の記録 | - |

## ログフォーマット

### 標準ログフォーマット (JSON Lines)

```typescript
interface LogEntry {
  // 基本情報
  timestamp: string;          // ISO 8601形式
  level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'FATAL';
  category: string;           // ログカテゴリ
  message: string;            // ログメッセージ

  // コンテキスト情報
  requestId: string;          // リクエストID (トレーシング)
  traceId?: string;           // 分散トレースID
  spanId?: string;            // スパンID

  // 認証情報
  userId?: string;            // 社員ID
  userEmail?: string;         // メールアドレス
  userRole?: string;          // ロール

  // リクエスト情報
  method?: string;            // HTTPメソッド
  path?: string;              // APIパス
  statusCode?: number;        // HTTPステータス
  duration?: number;          // 処理時間 (ms)

  // 追加コンテキスト
  context?: Record<string, unknown>;

  // エラー情報
  error?: {
    code: string;
    message: string;
    stack?: string;
  };

  // 環境情報
  environment: string;        // production | staging
  service: string;            // サービス名
  version: string;            // アプリバージョン
}
```

### ログ出力例

#### アクセスログ

```json
{
  "timestamp": "2026-01-24T10:30:00.000Z",
  "level": "INFO",
  "category": "ACCESS",
  "message": "API request completed",
  "requestId": "req_abc123",
  "userId": "emp_001",
  "userEmail": "tanaka@example.com",
  "userRole": "EMPLOYEE",
  "method": "POST",
  "path": "/api/v1/cycles/cycle_001/self-evaluation/submit",
  "statusCode": 200,
  "duration": 245,
  "environment": "production",
  "service": "evaluation-api",
  "version": "1.0.0"
}
```

#### 監査ログ (AUDIT_HANDLER)

```json
{
  "timestamp": "2026-01-24T10:30:00.000Z",
  "level": "INFO",
  "category": "AUDIT",
  "message": "Self evaluation submitted",
  "requestId": "req_abc123",
  "userId": "emp_001",
  "userEmail": "tanaka@example.com",
  "context": {
    "event": "SELF_EVALUATION_SUBMITTED",
    "cycleId": "cycle_001",
    "periodId": "period_2026_h1",
    "previousStatus": "DRAFT",
    "newStatus": "SELF_SUBMITTED",
    "scoreCount": 10,
    "evidenceProvided": true
  },
  "environment": "production",
  "service": "evaluation-api",
  "version": "1.0.0"
}
```

#### ワークフローログ (WORKFLOW_HANDLER)

```json
{
  "timestamp": "2026-01-24T10:30:00.000Z",
  "level": "INFO",
  "category": "WORKFLOW",
  "message": "Workflow status transitioned",
  "requestId": "req_abc123",
  "context": {
    "workflowInstanceId": "wfi_001",
    "workflowType": "EVALUATION_CYCLE",
    "entityId": "cycle_001",
    "fromStatus": "DRAFT",
    "toStatus": "SELF_SUBMITTED",
    "action": "submitSelfEvaluation",
    "actor": "emp_001",
    "stepOrder": 1
  },
  "environment": "production",
  "service": "evaluation-workflow",
  "version": "1.0.0"
}
```

#### 通知ログ (NOTIFICATION_HANDLER)

```json
{
  "timestamp": "2026-01-24T10:30:00.000Z",
  "level": "INFO",
  "category": "NOTIFICATION",
  "message": "Notification sent",
  "requestId": "req_abc123",
  "context": {
    "notificationType": "PEER_EVALUATION_REQUEST",
    "channel": "EMAIL",
    "recipientId": "emp_002",
    "recipientEmail": "yamada@example.com",
    "relatedEntity": {
      "type": "EvaluationCycle",
      "id": "cycle_001"
    },
    "sendResult": "SUCCESS",
    "messageId": "msg_xyz789"
  },
  "environment": "production",
  "service": "evaluation-notification-worker",
  "version": "1.0.0"
}
```

#### エラーログ

```json
{
  "timestamp": "2026-01-24T10:30:00.000Z",
  "level": "ERROR",
  "category": "ERROR",
  "message": "Workflow transition failed",
  "requestId": "req_abc123",
  "userId": "emp_001",
  "method": "POST",
  "path": "/api/v1/cycles/cycle_001/approve",
  "statusCode": 409,
  "error": {
    "code": "WORKFLOW_INVALID_TRANSITION",
    "message": "この状態からの遷移は許可されていません",
    "stack": "WorkflowError: ...\n    at validateTransition (/src/domain/services/workflow.ts:45:11)"
  },
  "context": {
    "currentStatus": "DRAFT",
    "attemptedAction": "approveByManager"
  },
  "environment": "production",
  "service": "evaluation-api",
  "version": "1.0.0"
}
```

## ドメインイベントログ

オントロジーのDomainEventに基づく監査対象イベント:

### 評価関連イベント

| イベントコード | ログメッセージ | 記録内容 |
|--------------|--------------|---------|
| `EVALUATION_PERIOD_CREATED` | 評価期間が作成されました | periodId, name, startDate, endDate |
| `EVALUATION_PERIOD_ACTIVATED` | 評価期間が開始されました | periodId, targetEmployeeCount |
| `SELF_EVALUATION_SUBMITTED` | 自己評価が提出されました | cycleId, scoreCount, evidenceCount |
| `PEER_EVALUATIONS_COMPLETED` | 同僚評価が完了しました | cycleId, peerCount, averageScore |
| `MANAGER_EVALUATION_SUBMITTED` | 上司評価が提出されました | cycleId, finalScore, comment |
| `EVALUATION_APPROVED` | 評価が承認されました | cycleId, approver, approverRole |
| `EVALUATION_REJECTED` | 評価が差戻しされました | cycleId, rejector, reason |
| `EVALUATION_FINALIZED` | 評価が確定されました | cycleId, finalGrade, salaryImpact |

### カリキュラム関連イベント

| イベントコード | ログメッセージ | 記録内容 |
|--------------|--------------|---------|
| `SCENARIO_CREATED` | シナリオが作成されました | scenarioId, title, questionCount |
| `CURRICULUM_GENERATED` | カリキュラムが生成されました | curriculumId, itemCount, noiseTypes |
| `CURRICULUM_APPROVED` | カリキュラムが承認されました | curriculumId, reviewer |
| `CURRICULUM_ASSIGNED` | カリキュラムが配信されました | curriculumId, assigneeCount |
| `LEARNING_COMPLETED` | 学習が完了しました | assignmentId, score, duration |

## ロギング実装

### 1. ロガークラス

```typescript
// infrastructure/logging/logger.ts
import { Context } from 'hono';

export class Logger {
  private readonly service: string;
  private readonly version: string;
  private readonly environment: string;

  constructor(config: { service: string; version: string; environment: string }) {
    this.service = config.service;
    this.version = config.version;
    this.environment = config.environment;
  }

  private log(
    level: string,
    category: string,
    message: string,
    context?: Record<string, unknown>
  ): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: level as LogEntry['level'],
      category,
      message,
      requestId: context?.requestId as string,
      userId: context?.userId as string,
      userEmail: context?.userEmail as string,
      userRole: context?.userRole as string,
      method: context?.method as string,
      path: context?.path as string,
      statusCode: context?.statusCode as number,
      duration: context?.duration as number,
      context: context?.data as Record<string, unknown>,
      error: context?.error as LogEntry['error'],
      environment: this.environment,
      service: this.service,
      version: this.version
    };

    // Cloudflare Workers: console.log outputs to Workers Logs
    console.log(JSON.stringify(entry));
  }

  debug(category: string, message: string, context?: Record<string, unknown>): void {
    if (this.environment !== 'production') {
      this.log('DEBUG', category, message, context);
    }
  }

  info(category: string, message: string, context?: Record<string, unknown>): void {
    this.log('INFO', category, message, context);
  }

  warn(category: string, message: string, context?: Record<string, unknown>): void {
    this.log('WARN', category, message, context);
  }

  error(category: string, message: string, error: Error, context?: Record<string, unknown>): void {
    this.log('ERROR', category, message, {
      ...context,
      error: {
        code: (error as any).code || 'UNKNOWN',
        message: error.message,
        stack: error.stack
      }
    });
  }

  fatal(category: string, message: string, error: Error, context?: Record<string, unknown>): void {
    this.log('FATAL', category, message, {
      ...context,
      error: {
        code: (error as any).code || 'UNKNOWN',
        message: error.message,
        stack: error.stack
      }
    });
  }
}

// シングルトンインスタンス
export const logger = new Logger({
  service: 'evaluation-api',
  version: '1.0.0',
  environment: process.env.ENVIRONMENT || 'development'
});
```

### 2. リクエストロギングミドルウェア

```typescript
// adapters/in/http/middleware/logging.ts
import { Context, Next } from 'hono';
import { logger } from '@/infrastructure/logging/logger';

export async function loggingMiddleware(c: Context, next: Next): Promise<Response> {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();

  // リクエストIDをコンテキストに設定
  c.set('requestId', requestId);

  // ユーザー情報を取得 (Cloudflare Access JWTから)
  const user = c.get('user');

  try {
    await next();

    const duration = Date.now() - startTime;

    // アクセスログ出力
    logger.info('ACCESS', 'API request completed', {
      requestId,
      userId: user?.sub,
      userEmail: user?.email,
      userRole: user?.role,
      method: c.req.method,
      path: c.req.path,
      statusCode: c.res.status,
      duration,
      data: {
        query: Object.fromEntries(new URL(c.req.url).searchParams),
        userAgent: c.req.header('user-agent')
      }
    });

    return c.res;
  } catch (error) {
    const duration = Date.now() - startTime;

    // エラーログ出力
    logger.error('ERROR', 'API request failed', error as Error, {
      requestId,
      userId: user?.sub,
      userEmail: user?.email,
      method: c.req.method,
      path: c.req.path,
      duration
    });

    throw error;
  }
}
```

### 3. 監査ロガー (AUDIT_HANDLER)

```typescript
// infrastructure/logging/audit-logger.ts
import { logger } from './logger';

interface AuditEvent {
  event: string;
  entityType: string;
  entityId: string;
  actor: {
    userId: string;
    email: string;
    role: string;
  };
  changes?: {
    field: string;
    before: unknown;
    after: unknown;
  }[];
  metadata?: Record<string, unknown>;
}

export class AuditLogger {
  log(requestId: string, event: AuditEvent): void {
    logger.info('AUDIT', `${event.event} - ${event.entityType}`, {
      requestId,
      userId: event.actor.userId,
      userEmail: event.actor.email,
      userRole: event.actor.role,
      data: {
        event: event.event,
        entityType: event.entityType,
        entityId: event.entityId,
        changes: event.changes,
        ...event.metadata
      }
    });

    // D1に監査レコードを永続化
    this.persistAuditRecord(event);
  }

  private async persistAuditRecord(event: AuditEvent): Promise<void> {
    // workflow_events テーブルに記録
    // 非同期で実行（ログ出力をブロックしない）
  }
}

export const auditLogger = new AuditLogger();
```

### 4. ワークフローロガー (WORKFLOW_HANDLER)

```typescript
// infrastructure/logging/workflow-logger.ts
import { logger } from './logger';

interface WorkflowTransition {
  workflowInstanceId: string;
  workflowType: string;
  entityId: string;
  fromStatus: string;
  toStatus: string;
  action: string;
  actor: string;
  stepOrder: number;
}

export class WorkflowLogger {
  logTransition(requestId: string, transition: WorkflowTransition): void {
    logger.info('WORKFLOW', 'Workflow status transitioned', {
      requestId,
      data: transition
    });
  }

  logStepStarted(requestId: string, step: { instanceId: string; stepCode: string; stepName: string }): void {
    logger.info('WORKFLOW', `Workflow step started: ${step.stepName}`, {
      requestId,
      data: step
    });
  }

  logStepCompleted(requestId: string, step: { instanceId: string; stepCode: string; duration: number }): void {
    logger.info('WORKFLOW', `Workflow step completed: ${step.stepCode}`, {
      requestId,
      data: step
    });
  }

  logStepFailed(requestId: string, step: { instanceId: string; stepCode: string }, error: Error): void {
    logger.error('WORKFLOW', `Workflow step failed: ${step.stepCode}`, error, {
      requestId,
      data: step
    });
  }
}

export const workflowLogger = new WorkflowLogger();
```

### 5. 通知ロガー (NOTIFICATION_HANDLER)

```typescript
// infrastructure/logging/notification-logger.ts
import { logger } from './logger';

interface NotificationLog {
  notificationType: string;
  channel: 'EMAIL' | 'SLACK' | 'IN_APP';
  recipientId: string;
  recipientEmail?: string;
  relatedEntity: {
    type: string;
    id: string;
  };
  sendResult: 'SUCCESS' | 'FAILED' | 'PENDING';
  messageId?: string;
  errorMessage?: string;
}

export class NotificationLogger {
  logSent(requestId: string, notification: NotificationLog): void {
    const level = notification.sendResult === 'FAILED' ? 'error' : 'info';

    if (level === 'error') {
      logger.error('NOTIFICATION', 'Notification failed', new Error(notification.errorMessage || 'Unknown error'), {
        requestId,
        data: notification
      });
    } else {
      logger.info('NOTIFICATION', 'Notification sent', {
        requestId,
        data: notification
      });
    }
  }

  logQueued(requestId: string, notification: Omit<NotificationLog, 'sendResult'>): void {
    logger.info('NOTIFICATION', 'Notification queued', {
      requestId,
      data: { ...notification, sendResult: 'PENDING' }
    });
  }
}

export const notificationLogger = new NotificationLogger();
```

## ログ保持ポリシー

| ログカテゴリ | 保持期間 | 保存先 |
|------------|---------|-------|
| ACCESS | 90日 | Cloudflare Workers Logs |
| AUDIT | 7年 | D1 (workflow_events) + 外部ストレージ |
| WORKFLOW | 1年 | D1 (workflow_step_histories) |
| NOTIFICATION | 90日 | D1 (notifications) |
| ERROR | 1年 | Cloudflare Workers Logs + Sentry |
| PERFORMANCE | 30日 | Cloudflare Analytics |

## モニタリング連携

### Cloudflare Workers Analytics

```typescript
// パフォーマンスメトリクスの送信
env.ANALYTICS.writeDataPoint({
  blobs: ['evaluation-api', 'self-evaluation-submit'],
  doubles: [duration, scoreCount],
  indexes: [statusCode.toString()]
});
```

### アラート条件

| 条件 | 閾値 | 通知先 |
|------|------|-------|
| エラー率 | > 1% (5分間) | Slack #alerts |
| レスポンスタイム | p99 > 3000ms | Slack #alerts |
| ワークフロー失敗 | > 5件/時 | Slack #alerts + PagerDuty |
| 認証エラー | > 10件/分 | Slack #security |

---

_最終更新: 2026年1月24日_
_派生元: Neo4j Ontology (EventHandler, DomainEvent, BusinessEvent)_

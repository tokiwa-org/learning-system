# チェックポイント：セキュアな実装を学ぼう

## メタ情報

```yaml
mission: "SQLインジェクション攻撃を阻止しよう"
step: 3
subStep: 6
title: "チェックポイント"
itemType: QUIZ
estimatedMinutes: 30
noiseLevel: MINIMAL
roadmap:
  skill: "セキュアコーディング"
  category: "セキュリティ"
  target_level: "L1"
passingScore: 80
```

---

## クイズの説明

Step 3で学んだ内容の理解度をチェックします。

- 全8問
- 合格ライン: 80%（7問正解）
- 不合格の場合は復習してから再挑戦してください

---

## 問題

### Q1. パラメータ化クエリがSQLインジェクションを防ぐ理由として正しいものはどれですか？

- A) ユーザー入力からシングルクオートを自動的に削除するから
- B) SQL文の構造と値を分離し、入力を常にデータとして扱うから
- C) クエリの実行速度が速くなり、攻撃の余地がなくなるから
- D) データベースが自動的に危険な文字列を検出するから

<details>
<summary>答えを見る</summary>

**正解: B**

パラメータ化クエリでは、SQL文のテンプレート（構造）がまず解析・コンパイルされ、
その後にパラメータ（値）がバインドされます。

このため、ユーザー入力が `' OR 1=1 --` であっても、
SQL構文として解釈されることはなく、単なる文字列データとして比較されます。

</details>

---

### Q2. Zodを使ったバリデーションの利点として正しいものはどれですか？

- A) クライアントサイドのバリデーションを自動生成する
- B) SQLインジェクションを自動的に防止する
- C) 型安全なバリデーション結果が得られ、不正な入力を早期に拒否できる
- D) データベースへの接続を暗号化する

<details>
<summary>答えを見る</summary>

**正解: C**

Zodはバリデーション成功時に型安全なデータを返します（`result.data`）。
これにより、バリデーション後のコードでは型の恩恵を受けながら、
不正な入力が処理ロジックに到達することを防げます。

Zodはバリデーションツールであり、SQLインジェクション対策やDB暗号化は
別の仕組み（パラメータ化クエリ、TLS等）で行います。

</details>

---

### Q3. ホワイトリスト方式がブラックリスト方式より安全な理由はどれですか？

- A) ホワイトリストの方が実装が簡単だから
- B) 許可するパターンのみを受け入れるため、未知の攻撃パターンも防げるから
- C) ホワイトリストの方が処理速度が速いから
- D) ブラウザがホワイトリストしかサポートしていないから

<details>
<summary>答えを見る</summary>

**正解: B**

ブラックリスト方式は「既知の危険パターン」を禁止するため、
攻撃者が新しいバイパス方法を見つけると突破されます。

ホワイトリスト方式は「許可するパターン」のみを受け入れるため、
未知の攻撃パターンであっても、許可リストに合致しなければ拒否されます。

</details>

---

### Q4. innerHTML と textContent の違いとして正しいものはどれですか？

- A) innerHTML はHTMLとして解釈し、textContent はテキストとして表示する
- B) innerHTML はテキストとして表示し、textContent はHTMLとして解釈する
- C) 両方ともHTMLとして解釈する
- D) 両方ともテキストとして表示する

<details>
<summary>答えを見る</summary>

**正解: A**

- `innerHTML`: 文字列をHTMLとして解釈し、タグを含む場合はDOMに反映される。`<script>` タグが含まれると実行される可能性がある
- `textContent`: 文字列をプレーンテキストとして表示する。HTMLタグは文字列としてそのまま画面に表示される

XSS対策としては、ユーザー入力を表示する場合は `textContent` を使用し、
HTMLを表示する必要がある場合は DOMPurify でサニタイズした上で `innerHTML` を使用します。

</details>

---

### Q5. Content-Security-Policy ヘッダーの `script-src 'self'` が意味するものはどれですか？

- A) 全てのスクリプトの実行を禁止する
- B) 同一オリジンからのスクリプトのみ実行を許可する
- C) インラインスクリプトのみ実行を許可する
- D) 外部CDNからのスクリプトのみ実行を許可する

<details>
<summary>答えを見る</summary>

**正解: B**

`script-src 'self'` は、同一オリジン（同じプロトコル、ドメイン、ポート）から
提供されるスクリプトファイルのみ実行を許可するCSPディレクティブです。

インラインスクリプト（`<script>alert(1)</script>`）や外部CDNからのスクリプトは
ブロックされます。これにより、XSSで注入されたインラインスクリプトが実行されません。

</details>

---

### Q6. helmet.js の役割として正しいものはどれですか？

- A) パスワードを暗号化するミドルウェア
- B) 推奨されるセキュリティヘッダーを一括で設定するミドルウェア
- C) SQLインジェクションを防ぐミドルウェア
- D) ログインセッションを管理するミドルウェア

<details>
<summary>答えを見る</summary>

**正解: B**

helmet.js は Express アプリケーションに対して、
CSP、HSTS、X-Frame-Options、X-Content-Type-Options などの
推奨されるセキュリティヘッダーを一括で設定するミドルウェアです。

`app.use(helmet())` の1行で、多くのセキュリティヘッダーがデフォルト値で設定されます。

</details>

---

### Q7. Cookie の HttpOnly 属性の目的はどれですか？

- A) Cookieの暗号化
- B) HTTPSでのみCookieを送信する
- C) JavaScriptからCookieへのアクセスを禁止する
- D) クロスサイトでのCookie送信を禁止する

<details>
<summary>答えを見る</summary>

**正解: C**

`HttpOnly` 属性が設定されたCookieは、`document.cookie` などの
JavaScriptからアクセスできなくなります。

これにより、XSS攻撃でスクリプトが実行されたとしても、
セッションCookieを窃取することができなくなります。

Bは `Secure` 属性、Dは `SameSite` 属性の説明です。

</details>

---

### Q8. CORS で `origin: '*'` を設定することの問題として正しいものはどれですか？

- A) パフォーマンスが低下する
- B) 全てのオリジンからのリクエストを許可してしまい、意図しないサイトからAPIにアクセスされる
- C) HTTPSが使えなくなる
- D) Cookieが送信できなくなる

<details>
<summary>答えを見る</summary>

**正解: B**

`origin: '*'` はすべてのオリジンからのリクエストを許可するため、
悪意のあるサイトからもAPIにアクセスされる可能性があります。

特に認証が必要なAPIや、機密データを返すAPIでは、
アクセスを許可するオリジンを明示的に指定する必要があります。

なお、`origin: '*'` と `credentials: true` は同時に設定できないため、
Dも部分的に正しいですが、最も重要な問題はBです。

</details>

---

## 結果

### 7問以上正解の場合

**合格です。おめでとうございます。**

Step 3「セキュアな実装を学ぼう」を完了しました。
次は Step 4「OAuth/JWTを実装しよう」に進みましょう。

### 6問以下の場合

**もう少し復習しましょう。**

| 問題 | 復習セクション |
|------|---------------|
| Q1 | step3_1 パラメータ化クエリ |
| Q2, Q3 | step3_2 入力値のサニタイズとバリデーション |
| Q4, Q5 | step3_3 出力エスケープでXSSを防ごう |
| Q6, Q7, Q8 | step3_4 セキュリティヘッダー |

---

## Step 3 完了

お疲れさまでした。

### 学んだこと

- パラメータ化クエリによるSQLインジェクション対策
- Zodによる入力バリデーション
- 出力エスケープとCSPによるXSS対策
- セキュリティヘッダーとCORSの設定
- helmet.js による一括設定

### 次のステップ

**Step 4: OAuth/JWTを実装しよう（5時間）**

セキュアなコードの書き方を身につけた今、次は認証・認可の仕組みを学びます。

---

*推定所要時間: 30分*
